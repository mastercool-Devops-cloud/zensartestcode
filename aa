
Flipkart is one of the most popular web portals that allows users to place online purchase order for books, mobiles & cars. Please find below the purchase order details:
Order Type
Order Details
Book purchase
id, book title, book author, price, order placement date, customer name, customer email, customer mobile
Mobile purchase
id, mobile vendor, model, price, order placement date, customer name, customer email, customer mobile
Car purchase
Id, car vendor, model, color, price, order placement date, customer name, customer email, customer mobile
The order processing is different for every order type. Hence, we need separate order processor for each order type.
Solution:
Solution:
1. Create a Kafka cluster with a topic ‘FlipkartOrdersTopic’ having separate partition for each order type. Make sure you keep at least one replica of every partition so that failure scenario can be handled.
2. Purchase order producer is continuously pushing orders into the topic & depending upon the order type, the message should automatically route to respective partition. Here, you need to write custom serializer & custom partitioner.
3. Create a consumer group having 3 consumers each one is consuming messages from the respective partition. You need to log all orders on console to prove that every consumer is consuming orders from respective order type only.
4. Write a Kafka Streams program that continuously reads orders & displays report of number of orders & total transaction amount against every order type. i.e. “Books_order_count”: 230, “Books_total_transaction_amount”: 2500000, “Mobiles_order_count”: 410, “Mobiles_total_transaction_amount”: 9000000,
“Cars_order_count”: 57, “Cars_total_transaction_amount”: 65400000,

----------------------------------------------------------------
//create 3 threads for each order type. Every thread dynamically creates random order & pushes to the topic.
		//Every type of order is having different message key (flipkart.car.order, flipkart.mobile.order, flipkart.book.order)
		
		//Use ExecutorService to create thread pool having at least 3 threads.

//write a code that generates car orders & send to the 'OrderTopic'

import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;

import java.util.Properties;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class OrderProducer {

    private static final String TOPIC = "order_topic";
    private static final Random RANDOM = new Random();

    public static void main(String[] args) {
        // Create Kafka producer configuration
        Properties props = new Properties();
        props.put("bootstrap.servers", "localhost:9092");
        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

        KafkaProducer<String, String> producer = new KafkaProducer<>(props);

        // Create an ExecutorService with a thread pool of 3 threads
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        // Submit tasks for each order type
        executorService.submit(() -> generateOrders(producer, "flipkart.car.order"));
        executorService.submit(() -> generateOrders(producer, "flipkart.mobile.order"));
        executorService.submit(() -> generateOrders(producer, "flipkart.book.order"));

        // Shutdown the executor service after some time
        executorService.shutdown();
        try {
            executorService.awaitTermination(10, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Close the producer
        producer.close();
    }

    private static void generateOrders(KafkaProducer<String, String> producer, String messageKey) {
        for (int i = 0; i < 10; i++) { // Generating 10 orders dynamically for each order type
            String order = createRandomOrder(messageKey);
            ProducerRecord<String, String> record = new ProducerRecord<>(TOPIC, messageKey, order);

            // Send the message asynchronously
            Future<RecordMetadata> future = producer.send(record, (metadata, exception) -> {
                if (exception != null) {
                    System.err.println("Error producing to topic: " + exception.getMessage());
                } else {
                    System.out.printf("Produced record to topic %s partition [%d] @ offset %d with key %s\n",
                            metadata.topic(), metadata.partition(), metadata.offset(), messageKey);
                }
            });

            try {
                future.get(); // Wait for the result of the send
            } catch (Exception e) {
                e.printStackTrace();
            }

            // Sleep for a short time to simulate dynamic order creation
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // Simulate creating a random order for the given order type
    private static String createRandomOrder(String orderType) {
        int orderId = RANDOM.nextInt(1000);
        return String.format("{\"orderId\": %d, \"orderType\": \"%s\", \"details\": \"Order details for %s\"}",
                orderId, orderType, orderType);
    }
}


