import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;
import java.util.*;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.apache.http.HttpStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.MockedStatic;

@ExtendWith(MockitoExtension.class)
class RequestLogFilterTest {

    private RequestLogFilter requestLogFilter;

    @Mock
    private HttpServletRequest httpRequest;

    @Mock
    private HttpServletResponse httpResponse;

    @Mock
    private FilterChain filterChain;

    @Mock
    private CachedBodyHttpServletRequestWrapper cachedRequestWrapper;

    @BeforeEach
    void setUp() {
        requestLogFilter = new RequestLogFilter("test-app", "test-env");
    }

    @Test
    void testDoFilter_Success() throws IOException, ServletException {
        when(httpRequest.getMethod()).thenReturn("POST");
        when(httpRequest.getRequestURI()).thenReturn("/test-endpoint");
        when(httpResponse.getStatus()).thenReturn(200);
        when(httpRequest.getHeader("Content-Length")).thenReturn("200");
        when(httpRequest.getContentType()).thenReturn("application/json");

        Map<String, String> requestBody = Collections.singletonMap("key", "value");

        try (
            MockedStatic<CachedBodyHttpServletRequestWrapper> mockWrapper = mockStatic(CachedBodyHttpServletRequestWrapper.class);
            MockedStatic<HttpRequestLogHelper> mockLogHelper = mockStatic(HttpRequestLogHelper.class);
            MockedStatic<LogProcessorFactory> mockLogProcessor = mockStatic(LogProcessorFactory.class)
        ) {
            mockWrapper.when(() -> new CachedBodyHttpServletRequestWrapper(httpRequest)).thenReturn(cachedRequestWrapper);
            mockLogHelper.when(() -> HttpRequestLogHelper.getRequestBody(any())).thenReturn(requestBody);

            requestLogFilter.doFilter(httpRequest, httpResponse, filterChain);

            mockWrapper.verify(() -> new CachedBodyHttpServletRequestWrapper(httpRequest), times(1));

            mockLogProcessor.verify(() -> LogProcessorFactory.processLog(
                argThat(log -> log instanceof RestLog), eq(LogType.REQUEST)
            ), times(1));

            verify(filterChain, times(1)).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));
        }
    }

    @Test
    void testDoFilter_ExceptionHandling() throws IOException, ServletException {
        when(httpRequest.getMethod()).thenReturn("POST");
        when(httpRequest.getRequestURI()).thenReturn("/test-endpoint");

        try (
            MockedStatic<CachedBodyHttpServletRequestWrapper> mockWrapper = mockStatic(CachedBodyHttpServletRequestWrapper.class);
            MockedStatic<LogProcessorFactory> mockLogProcessor = mockStatic(LogProcessorFactory.class)
        ) {
            mockWrapper.when(() -> new CachedBodyHttpServletRequestWrapper(httpRequest))
                       .thenThrow(new RuntimeException("Test Exception"));

            Exception exception = assertThrows(RuntimeException.class, () -> 
                requestLogFilter.doFilter(httpRequest, httpResponse, filterChain)
            );

            assertEquals("Test Exception", exception.getMessage());

            mockLogProcessor.verify(() -> LogProcessorFactory.processLog(
                argThat(log -> log instanceof ErrorLog), eq(LogType.ERROR)
            ), times(1));
        }
    }

    @Test
    void testDoFilter_NullRequestBody() throws IOException, ServletException {
        when(httpRequest.getMethod()).thenReturn("POST");
        when(httpRequest.getRequestURI()).thenReturn("/test-endpoint");
        when(httpResponse.getStatus()).thenReturn(200);

        try (
            MockedStatic<CachedBodyHttpServletRequestWrapper> mockWrapper = mockStatic(CachedBodyHttpServletRequestWrapper.class);
            MockedStatic<HttpRequestLogHelper> mockLogHelper = mockStatic(HttpRequestLogHelper.class);
            MockedStatic<LogProcessorFactory> mockLogProcessor = mockStatic(LogProcessorFactory.class)
        ) {
            mockWrapper.when(() -> new CachedBodyHttpServletRequestWrapper(httpRequest)).thenReturn(cachedRequestWrapper);
            mockLogHelper.when(() -> HttpRequestLogHelper.getRequestBody(any())).thenReturn(null); // Simulate null request body

            requestLogFilter.doFilter(httpRequest, httpResponse, filterChain);

            mockLogProcessor.verify(() -> LogProcessorFactory.processLog(
                argThat(log -> log instanceof RestLog), eq(LogType.REQUEST)
            ), times(1));

            verify(filterChain, times(1)).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));
        }
    }

    @Test
    void testDoFilter_EmptyRequestBody() throws IOException, ServletException {
        when(httpRequest.getMethod()).thenReturn("POST");
        when(httpRequest.getRequestURI()).thenReturn("/test-endpoint");
        when(httpResponse.getStatus()).thenReturn(200);

        try (
            MockedStatic<CachedBodyHttpServletRequestWrapper> mockWrapper = mockStatic(CachedBodyHttpServletRequestWrapper.class);
            MockedStatic<HttpRequestLogHelper> mockLogHelper = mockStatic(HttpRequestLogHelper.class);
            MockedStatic<LogProcessorFactory> mockLogProcessor = mockStatic(LogProcessorFactory.class)
        ) {
            mockWrapper.when(() -> new CachedBodyHttpServletRequestWrapper(httpRequest)).thenReturn(cachedRequestWrapper);
            mockLogHelper.when(() -> HttpRequestLogHelper.getRequestBody(any())).thenReturn(Collections.emptyMap()); // Simulate empty request body

            requestLogFilter.doFilter(httpRequest, httpResponse, filterChain);

            mockLogProcessor.verify(() -> LogProcessorFactory.processLog(
                argThat(log -> log instanceof RestLog), eq(LogType.REQUEST)
            ), times(1));

            verify(filterChain, times(1)).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));
        }
    }

    @Test
    void testDoFilter_MissingHeaders() throws IOException, ServletException {
        when(httpRequest.getMethod()).thenReturn("POST");
        when(httpRequest.getRequestURI()).thenReturn("/test-endpoint");
        when(httpResponse.getStatus()).thenReturn(200);

        when(httpRequest.getHeader("Content-Length")).thenReturn(null);
        when(httpRequest.getHeader("Host")).thenReturn(null);
        when(httpRequest.getContentType()).thenReturn(null);

        try (
            MockedStatic<CachedBodyHttpServletRequestWrapper> mockWrapper = mockStatic(CachedBodyHttpServletRequestWrapper.class);
            MockedStatic<HttpRequestLogHelper> mockLogHelper = mockStatic(HttpRequestLogHelper.class);
            MockedStatic<LogProcessorFactory> mockLogProcessor = mockStatic(LogProcessorFactory.class)
        ) {
            mockWrapper.when(() -> new CachedBodyHttpServletRequestWrapper(httpRequest)).thenReturn(cachedRequestWrapper);
            mockLogHelper.when(() -> HttpRequestLogHelper.getRequestBody(any())).thenReturn(Collections.singletonMap("key", "value"));

            requestLogFilter.doFilter(httpRequest, httpResponse, filterChain);

            mockLogProcessor.verify(() -> LogProcessorFactory.processLog(
                argThat(log -> log instanceof RestLog), eq(LogType.REQUEST)
            ), times(1));

            verify(filterChain, times(1)).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));
        }
    }
}
------------------------------
org.mockito.exceptions.misusing.WrongTypeOfReturnValue: 
CachedBodyHttpServletRequestWrapper cannot be returned by getInputStream()
getInputStream() should return ServletInputStream
***
If you're unsure why you're getting above error read on.
Due to the nature of the syntax above problem might occur because:
1. This exception *might* occur in wrongly written multi-threaded tests.
   Please refer to Mockito FAQ on limitations of concurrency testing.
2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - 
   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.


	at com.sb.fedssimplification.utilitymodules.secretsmanager.filter.RequestLogFilterTest.testDoFilter_Success(RequestLogFilterTest.java:64)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)

import jakarta.servlet.ServletInputStream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import static org.mockito.Mockito.*;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

class RequestLogFilterTest {

    private RequestLogFilter requestLogFilter;
    private HttpServletRequest httpRequest;
    private HttpServletResponse httpResponse;
    private FilterChain filterChain;

    @BeforeEach
    void setUp() {
        // Initialize the objects needed for the test
        requestLogFilter = new RequestLogFilter("testApp", "dev");
        httpRequest = mock(HttpServletRequest.class);
        httpResponse = mock(HttpServletResponse.class);
        filterChain = mock(FilterChain.class);
    }

    @Test
    void testDoFilter_Success() throws IOException, ServletException {
        // Prepare the mock objects for the request and response
        when(httpRequest.getMethod()).thenReturn("POST");
        when(httpRequest.getRequestURI()).thenReturn("/test-endpoint");
        when(httpResponse.getStatus()).thenReturn(200);
        when(httpRequest.getHeader("Content-Length")).thenReturn("200");
        when(httpRequest.getContentType()).thenReturn("application/json");

        // Mock the behavior of getInputStream
        byte[] mockRequestBody = "{\"key\":\"value\"}".getBytes();
        ServletInputStream mockInputStream = new CachedBodyServletInputStream(mockRequestBody); // Your custom input stream

        // Create a mocked wrapped request that returns the mock input stream
        CachedBodyHttpServletRequestWrapper wrappedRequest = mock(CachedBodyHttpServletRequestWrapper.class);
        when(wrappedRequest.getInputStream()).thenReturn(mockInputStream);

        Map<String, String> requestBody = Map.of("key", "value");

        try (MockedStatic<LogProcessorFactory> mockLogProcessor = mockStatic(LogProcessorFactory.class);
             MockedStatic<HttpRequestLogHelper> mockLogHelper = mockStatic(HttpRequestLogHelper.class)) {

            // Mock static methods to return desired behavior
            mockLogHelper.when(() -> HttpRequestLogHelper.getRequestBody(wrappedRequest)).thenReturn(requestBody);

            // Run the filter method
            requestLogFilter.doFilter(httpRequest, httpResponse, filterChain);

            // Verify the log method was called
            mockLogProcessor.verify(() -> LogProcessorFactory.processLog(
                argThat(log -> log instanceof RestLog), eq(LogType.REQUEST)
            ), times(1));

            // Verify filterChain.doFilter was called
            verify(filterChain, times(1)).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));
        }
    }
}


---------------------
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected.
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -> at com.sb.fedssimplification.utilitymodules.secretsmanager.filter.RequestLogFilterTest.testDoFilter_ExceptionHandling(RequestLogFilterTest.java:81)
  2. -> at com.sb.fedssimplification.utilitymodules.secretsmanager.filter.RequestLogFilterTest.testDoFilter_ExceptionHandling(RequestLogFilterTest.java:82)
Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class.

	at org.mockito.junit.jupiter.MockitoExtension.afterEach(MockitoExtension.java:197)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
-----------------------------------------
org.mockito.exceptions.misusing.WrongTypeOfReturnValue: 
CachedBodyHttpServletRequestWrapper cannot be returned by getInputStream()
getInputStream() should return ServletInputStream
***
If you're unsure why you're getting above error read on.
Due to the nature of the syntax above problem might occur because:
1. This exception *might* occur in wrongly written multi-threaded tests.
   Please refer to Mockito FAQ on limitations of concurrency testing.
2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - 
   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.


	at com.sb.fedssimplification.utilitymodules.secretsmanager.filter.RequestLogFilterTest.testDoFilter_EmptyRequestBody(RequestLogFilterTest.java:138)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
---------------------------
org.mockito.exceptions.misusing.WrongTypeOfReturnValue: 
CachedBodyHttpServletRequestWrapper cannot be returned by getInputStream()
getInputStream() should return ServletInputStream
***
If you're unsure why you're getting above error read on.
Due to the nature of the syntax above problem might occur because:
1. This exception *might* occur in wrongly written multi-threaded tests.
   Please refer to Mockito FAQ on limitations of concurrency testing.
2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - 
   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.


	at com.sb.fedssimplification.utilitymodules.secretsmanager.filter.RequestLogFilterTest.testDoFilter_NullRequestBody(RequestLogFilterTest.java:114)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
----------------------------------------
org.mockito.exceptions.misusing.WrongTypeOfReturnValue: 
CachedBodyHttpServletRequestWrapper cannot be returned by getInputStream()
getInputStream() should return ServletInputStream
***
If you're unsure why you're getting above error read on.
Due to the nature of the syntax above problem might occur because:
1. This exception *might* occur in wrongly written multi-threaded tests.
   Please refer to Mockito FAQ on limitations of concurrency testing.
2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - 
   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.


	at com.sb.fedssimplification.utilitymodules.secretsmanager.filter.RequestLogFilterTest.testDoFilter_MissingHeaders(RequestLogFilterTest.java:166)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
