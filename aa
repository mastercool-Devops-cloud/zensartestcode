-----------------------------------
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;
import com.example.config.ApplicationProperties;  // Adjust package accordingly

@ExtendWith(org.springframework.test.context.junit.jupiter.SpringExtension.class)
@SpringBootTest
@TestPropertySource(properties = "spring.application.name=TestApplication")
class ApplicationPropertiesTest {

    @Autowired
    private ApplicationProperties applicationProperties;

    @Test
    void testApplicationName() {
        assertNotNull(applicationProperties);
        assertEquals("TestApplication", applicationProperties.getApplication());
    }
}
-----------------------------------------------
@ExtendWith(MockitoExtension.class)
@ExtendWith(SpringExtension.class)
class LoggingFilterConfigTest {

    @Mock
    private ApplicationProperties applicationProperties;

    @Mock
    private Environment environment;  // ✅ Mock the Environment

    private EnvironmentName environmentName;  // ✅ Remove @Mock, manually initialize

    @InjectMocks
    private LoggingFilterConfig loggingFilterConfig;

    @BeforeEach
    void setUp() {
        // Mock application name
        when(applicationProperties.getApplication()).thenReturn("TestApplication");

        // Mock environment profile
        when(environment.getActiveProfiles()).thenReturn(new String[]{"TestEnvironment"});

        // ✅ Manually inject environment into EnvironmentName
        environmentName = new EnvironmentName(environment);

        // ✅ Manually inject dependencies into LoggingFilterConfig
        loggingFilterConfig = new LoggingFilterConfig(applicationProperties, environmentName);
    }

    @Test
    void testRequestLogFilterBeanCreation() {
        RequestLogFilter requestLogFilter = loggingFilterConfig.requestLogFilter();

        assertNotNull(requestLogFilter);
        assertEquals("TestApplication", requestLogFilter.getApplicationName());
        assertEquals("TestEnvironment", requestLogFilter.getEnvironmentName());
    }

    @Test
    void testResponseLogFilterBeanCreation() {
        ResponseLogFilter responseLogFilter = loggingFilterConfig.responseLogFilter();

        assertNotNull(responseLogFilter);
        assertEquals("TestApplication", responseLogFilter.getApplicationName());
        assertEquals("TestEnvironment", responseLogFilter.getEnvironmentName());
    }
}
-----------------------------------------
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.env.Environment;

@ExtendWith(MockitoExtension.class)
class EnvironmentNameTest {

    @Mock
    private Environment environment;  // ✅ Mocked environment 

    @InjectMocks
    private EnvironmentName environmentName;  // ✅ Inject mock into class

    @BeforeEach
    void setUp() {
        when(environment.getActiveProfiles()).thenReturn(new String[]{"TestProfile"});
    }

    @Test
    void testGetActiveProfile_ReturnsActiveProfile() {
        assertEquals("TestProfile", environmentName.getActiveProfile());
    }

    @Test
    void testGetActiveProfile_ReturnsDefault_WhenNoActiveProfiles() {
        when(environment.getActiveProfiles()).thenReturn(new String[]{});
        assertEquals("default", environmentName.getActiveProfile());
    }
}


------------------------------------------------
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.web.util.ContentCachingResponseWrapper;

import java.io.IOException;
import java.util.Map;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ResponseLogFilterTest {

    @InjectMocks
    private ResponseLogFilter responseLogFilter;

    @Mock
    private HttpServletRequest mockRequest;

    @Mock
    private HttpServletResponse mockResponse;

    @Mock
    private FilterChain mockChain;

    @Mock
    private LogProcessor mockResponseProcessor;

    @Mock
    private LogProcessor mockExceptionProcessor;

    @BeforeEach
    void setUp() {
        responseLogFilter = new ResponseLogFilter("TestApp", "TestEnv");
    }

    @Test
    void testDoFilter_SuccessfulResponseProcessing() throws IOException, ServletException {
        // Create a wrapped response to simulate the behavior
        ContentCachingResponseWrapper wrappedResponse = new ContentCachingResponseWrapper(mockResponse);

        try (MockedStatic<LogProcessorFactory> mockedFactory = mockStatic(LogProcessorFactory.class)) {
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.RESPONSE))
                         .thenReturn(mockResponseProcessor);

            // Call the method under test
            responseLogFilter.doFilter(mockRequest, wrappedResponse, mockChain);

            // Verify doFilter is called correctly
            verify(mockChain).doFilter(eq(mockRequest), any(ContentCachingResponseWrapper.class));

            // Verify response logging
            verify(mockResponseProcessor).process(any(ContentCachingResponseWrapper.class), any(Map.class));

            // Ensure copyBodyToResponse() is called
            verify(mockResponseProcessor, never()).process(any(ContentCachingResponseWrapper.class), isNull());
        }
    }

    @Test
    void testDoFilter_ExceptionHandling() throws IOException, ServletException {
        // Create a wrapped response
        ContentCachingResponseWrapper wrappedResponse = new ContentCachingResponseWrapper(mockResponse);

        try (MockedStatic<LogProcessorFactory> mockedFactory = mockStatic(LogProcessorFactory.class)) {
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.RESPONSE))
                         .thenReturn(mockResponseProcessor);
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.ERROR))
                         .thenReturn(mockExceptionProcessor);

            // Simulate an exception during filter execution
            doThrow(new RuntimeException("Test Exception")).when(mockChain).doFilter(mockRequest, wrappedResponse);

            try {
                responseLogFilter.doFilter(mockRequest, wrappedResponse, mockChain);
            } catch (Exception e) {
                // Verify exception processor is invoked with correct parameters
                verify(mockExceptionProcessor).process(any(ContentCachingResponseWrapper.class), any(Map.class));
            }
        }
    }
}
-------------------------------------------
Argument(s) are different! Wanted:
mockExceptionProcessor.process(
    <any org.springframework.web.util.ContentCachingResponseWrapper>,
    <any java.util.Map>
);
-> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilterTest.testDoFilter_ExceptionHandling(ResponseLogFilterTest.java:83)
Actual invocations have different arguments at position [0]:
mockExceptionProcessor.process(
    org.mockito.exceptions.misusing.PotentialStubbingProblem: 
Strict stubbing argument mismatch. Please check:
 - this invocation of 'doFilter' method:
    mockChain.doFilter(
    mockRequest,
    org.springframework.web.util.ContentCachingResponseWrapper@35088e87
);
    -> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilter.doFilter(ResponseLogFilter.java:41)
 - has following stubbing(s) with different arguments:
    1. mockChain.doFilter(
    mockRequest,
    org.springframework.web.util.ContentCachingResponseWrapper@54aca26f
);
      -> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilterTest.testDoFilter_ExceptionHandling(ResponseLogFilterTest.java:78)
Typically, stubbing argument mismatch indicates user mistake when writing tests.
Mockito fails early so that you can debug potential problem easily.
However, there are legit scenarios when this exception generates false negative signal:
  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API
    Please use 'will().given()' or 'doReturn().when()' API for stubbing.
  - stubbed method is intentionally invoked with different arguments by code under test
    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).
For more information see javadoc for PotentialStubbingProblem class.,
    {}
);
-> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilter.doFilter(ResponseLogFilter.java:53)

Argument(s) are different! Wanted:
mockExceptionProcessor.process(
    <any org.springframework.web.util.ContentCachingResponseWrapper>,
    <any java.util.Map>
);
-> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilterTest.testDoFilter_ExceptionHandling(ResponseLogFilterTest.java:83)
Actual invocations have different arguments at position [0]:
mockExceptionProcessor.process(
    org.mockito.exceptions.misusing.PotentialStubbingProblem: 
Strict stubbing argument mismatch. Please check:
 - this invocation of 'doFilter' method:
    mockChain.doFilter(
    mockRequest,
    org.springframework.web.util.ContentCachingResponseWrapper@35088e87
);
    -> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilter.doFilter(ResponseLogFilter.java:41)
 - has following stubbing(s) with different arguments:
    1. mockChain.doFilter(
    mockRequest,
    org.springframework.web.util.ContentCachingResponseWrapper@54aca26f
);
      -> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilterTest.testDoFilter_ExceptionHandling(ResponseLogFilterTest.java:78)
Typically, stubbing argument mismatch indicates user mistake when writing tests.
Mockito fails early so that you can debug potential problem easily.
However, there are legit scenarios when this exception generates false negative signal:
  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API
    Please use 'will().given()' or 'doReturn().when()' API for stubbing.
  - stubbed method is intentionally invoked with different arguments by code under test
    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).
For more information see javadoc for PotentialStubbingProblem class.,
    {}
);
-> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilter.doFilter(ResponseLogFilter.java:53)

	at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilterTest.testDoFilter_ExceptionHandling(ResponseLogFilterTest.java:83)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)

------------------------------------------------
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.web.util.ContentCachingResponseWrapper;

import java.io.IOException;
import java.util.Map;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ResponseLogFilterTest {

    @InjectMocks
    private ResponseLogFilter responseLogFilter;

    @Mock
    private HttpServletRequest mockRequest;

    @Mock
    private HttpServletResponse mockResponse;

    @Mock
    private FilterChain mockChain;

    @Mock
    private LogProcessor mockResponseProcessor;

    @Mock
    private LogProcessor mockExceptionProcessor;

    @BeforeEach
    void setUp() {
        responseLogFilter = new ResponseLogFilter("TestApp", "TestEnv");
    }

    @Test
    void testDoFilter_SuccessfulResponseProcessing() throws IOException, ServletException {
        try (MockedStatic<LogProcessorFactory> mockedFactory = mockStatic(LogProcessorFactory.class)) {
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.RESPONSE))
                         .thenReturn(mockResponseProcessor);

            // Call the method under test
            responseLogFilter.doFilter(mockRequest, mockResponse, mockChain);

            // Verify doFilter is called correctly
            verify(mockChain).doFilter(eq(mockRequest), argThat(response -> response instanceof ContentCachingResponseWrapper));

            // Verify response logging
            verify(mockResponseProcessor).process(any(ContentCachingResponseWrapper.class), any(Map.class));
        }
    }

    @Test
    void testDoFilter_ExceptionHandling() throws IOException, ServletException {
        try (MockedStatic<LogProcessorFactory> mockedFactory = mockStatic(LogProcessorFactory.class)) {
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.RESPONSE))
                         .thenReturn(mockResponseProcessor);
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.ERROR))
                         .thenReturn(mockExceptionProcessor);

            // Simulate an exception during filter execution
            doThrow(new RuntimeException("Test Exception")).when(mockChain).doFilter(eq(mockRequest), any(ServletResponse.class));

            try {
                responseLogFilter.doFilter(mockRequest, mockResponse, mockChain);
            } catch (Exception e) {
                // Verify exception processor is invoked
                verify(mockExceptionProcessor).process(any(ContentCachingResponseWrapper.class), any(Map.class));
            }
        }
    }
}
--------------------------------------------
Argument(s) are different! Wanted:
mockExceptionProcessor.process(
    <any org.springframework.web.util.ContentCachingResponseWrapper>,
    <any java.util.Map>
);
-> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilterTest.testDoFilter_ExceptionHandling(ResponseLogFilterTest.java:84)
Actual invocations have different arguments at position [0]:
mockExceptionProcessor.process(
    java.lang.RuntimeException: Test Exception,
    {}
);
-> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilter.doFilter(ResponseLogFilter.java:53)

Argument(s) are different! Wanted:
mockExceptionProcessor.process(
    <any org.springframework.web.util.ContentCachingResponseWrapper>,
    <any java.util.Map>
);
-> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilterTest.testDoFilter_ExceptionHandling(ResponseLogFilterTest.java:84)
Actual invocations have different arguments at position [0]:
mockExceptionProcessor.process(
    java.lang.RuntimeException: Test Exception,
    {}
);
-> at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilter.doFilter(ResponseLogFilter.java:53)

	at com.sb.fedssimplification.cashflowcalculator.filter.ResponseLogFilterTest.testDoFilter_ExceptionHandling(ResponseLogFilterTest.java:84)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.web.util.ContentCachingResponseWrapper;

import java.io.IOException;
import java.util.Map;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ResponseLogFilterTest {

    @InjectMocks
    private ResponseLogFilter responseLogFilter;

    @Mock
    private HttpServletRequest mockRequest;

    @Mock
    private HttpServletResponse mockResponse;

    @Mock
    private FilterChain mockChain;

    @Mock
    private LogProcessor mockResponseProcessor;

    @Mock
    private LogProcessor mockExceptionProcessor;

    @BeforeEach
    void setUp() {
        responseLogFilter = new ResponseLogFilter("TestApp", "TestEnv");
    }

    @Test
    void testDoFilter_SuccessfulResponseProcessing() throws IOException, ServletException {
        try (MockedStatic<LogProcessorFactory> mockedFactory = mockStatic(LogProcessorFactory.class)) {
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.RESPONSE))
                         .thenReturn(mockResponseProcessor);

            responseLogFilter.doFilter(mockRequest, mockResponse, mockChain);

            verify(mockChain).doFilter(eq(mockRequest), argThat(response -> response instanceof ContentCachingResponseWrapper));
            verify(mockResponseProcessor).process(any(ContentCachingResponseWrapper.class), any(Map.class));
        }
    }

    @Test
    void testDoFilter_ExceptionHandling() throws IOException, ServletException {
        try (MockedStatic<LogProcessorFactory> mockedFactory = mockStatic(LogProcessorFactory.class)) {
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.RESPONSE))
                         .thenReturn(mockResponseProcessor);
            mockedFactory.when(() -> LogProcessorFactory.getLogProcessor(LogType.ERROR))
                         .thenReturn(mockExceptionProcessor);

            RuntimeException testException = new RuntimeException("Test Exception");
            doThrow(testException).when(mockChain).doFilter(eq(mockRequest), any(ServletResponse.class));

            try {
                responseLogFilter.doFilter(mockRequest, mockResponse, mockChain);
            } catch (Exception e) {
                // Verify the exception processor handles the thrown exception instead of the request/response wrapper
                verify(mockExceptionProcessor).process(eq(testException), any(Map.class));
            }
        }
    }
}

