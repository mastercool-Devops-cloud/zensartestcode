
import org.junit.jupiter.api.Test;
import org.springframework.mock.web.MockHttpServletRequest;

import static org.junit.jupiter.api.Assertions.assertEquals;

class ClientIpAddressUtilTest {

    @Test
    void testGetClientIpAddress_WithXForwardedForHeader() {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("X-Forwarded-For", "192.168.1.1");

        String clientIp = ClientIpAddressUtil.getClientIpAddress(request);

        assertEquals("192.168.1.1", clientIp);
    }

    @Test
    void testGetClientIpAddress_WithMultipleIPsInXForwardedForHeader() {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("X-Forwarded-For", "192.168.1.1, 10.0.0.1");

        String clientIp = ClientIpAddressUtil.getClientIpAddress(request);

        assertEquals("192.168.1.1", clientIp); // Should return the first IP
    }

    @Test
    void testGetClientIpAddress_WithUnknownIPInHeader() {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("X-Forwarded-For", "unknown");

        String clientIp = ClientIpAddressUtil.getClientIpAddress(request);

        assertEquals(request.getRemoteAddr(), clientIp); // Fallback to remote address
    }

    @Test
    void testGetClientIpAddress_WithNoHeaders() {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRemoteAddr("127.0.0.1"); // Simulate remote address

        String clientIp = ClientIpAddressUtil.getClientIpAddress(request);

        assertEquals("127.0.0.1", clientIp);
    }

    @Test
    void testGetClientIpAddress_WithCustomHeader() {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("HTTP_CLIENT_IP", "203.0.113.1");

        String clientIp = ClientIpAddressUtil.getClientIpAddress(request);

        assertEquals("203.0.113.1", clientIp);
    }
}
---------------------------------------
import nl.altindag.log.LogCaptor;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertTrue;

class LoggingUtilTest {

    private LogCaptor logCaptor;

    @BeforeEach
    void setUp() {
        logCaptor = LogCaptor.forClass(LoggingUtil.class);
    }

    @AfterEach
    void tearDown() {
        logCaptor.clearLogs();
    }

    @Test
    void testLogException_WithExceptionOnly() {
        Exception exception = new RuntimeException("Test exception message");

        LoggingUtil.logException(exception);

        // Validate the logs
        assertTrue(logCaptor.getErrorLogs().stream()
                .anyMatch(log -> log.contains("An exception occurred: Test exception message")));
        assertTrue(logCaptor.getErrorLogs().stream()
                .anyMatch(log -> log.contains("java.lang.RuntimeException: Test exception message")));
    }

    @Test
    void testLogException_WithExceptionAndContext() {
        Exception exception = new RuntimeException("Test exception with context");
        Map<String, Object> context = new HashMap<>();
        context.put("key1", "value1");
        context.put("key2", 123);

        LoggingUtil.logException(exception, context);

        // Validate the logs
        assertTrue(logCaptor.getErrorLogs().stream()
                .anyMatch(log -> log.contains("An exception occurred: Test exception with context")));
        assertTrue(logCaptor.getErrorLogs().stream()
                .anyMatch(log -> log.contains("Context: {\"key1\":\"value1\",\"key2\":123}")));
    }

    @Test
    void testLogException_WithNullContext() {
        Exception exception = new IllegalArgumentException("Test exception with null context");

        LoggingUtil.logException(exception, null);

        // Validate the logs
        assertTrue(logCaptor.getErrorLogs().stream()
                .anyMatch(log -> log.contains("An exception occurred: Test exception with null context")));
    }

    @Test
    void testLogException_WithContextSerializationError() {
        Exception exception = new IllegalStateException("Serialization error test");
        Map<String, Object> context = new HashMap<>() {
            @Override
            public String toString() {
                throw new RuntimeException("Serialization failed");
            }
        };

        LoggingUtil.logException(exception, context);

        // Validate the logs
        assertTrue(logCaptor.getErrorLogs().stream()
                .anyMatch(log -> log.contains("An exception occurred: Serialization error test")));
        assertTrue(logCaptor.getErrorLogs().stream()
                .anyMatch(log -> log.contains("Context could not be serialized.")));
    }

    @Test
    void testLogException_WithNullException() {
        LoggingUtil.logException(null);

        // Validate the logs
        assertTrue(logCaptor.getWarnLogs().stream()
                .anyMatch(log -> log.contains("Attempted to log a null exception.")));
    }
}
-------------------------------------------------
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.ApplicationContext;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
class LoggingFilterConfigTest {

    @Autowired
    private ApplicationContext context;

    @Test
    void testRequestCachingLoggingFilterRegistration() {
        FilterRegistrationBean<?> filterRegistrationBean = context.getBean("requestCachingLoggingFilter", FilterRegistrationBean.class);

        // Assert filter is registered
        assertThat(filterRegistrationBean).isNotNull();
        assertThat(filterRegistrationBean.getFilter()).isInstanceOf(RequestCachingLoggingFilter.class);

        // Assert URL patterns
        assertThat(filterRegistrationBean.getUrlPatterns()).containsExactly("/*");

        // Assert filter order
        assertThat(filterRegistrationBean.getOrder()).isEqualTo(1);
    }

    @Test
    void testResponseCachingLoggingFilterRegistration() {
        FilterRegistrationBean<?> filterRegistrationBean = context.getBean("responseCachingLoggingFilter", FilterRegistrationBean.class);

        // Assert filter is registered
        assertThat(filterRegistrationBean).isNotNull();
        assertThat(filterRegistrationBean.getFilter()).isInstanceOf(ResponseCachingLoggingFilter.class);

        // Assert URL patterns
        assertThat(filterRegistrationBean.getUrlPatterns()).containsExactly("/*");

        // Assert filter order
        assertThat(filterRegistrationBean.getOrder()).isEqualTo(2);
    }
}

org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'loggingFilter' available
 @Bean(name = "requestCachingLoggingFilter")
-----------------------------------------------
import javax.servlet.http.HttpServletRequest;

public class IpAddressUtil {

    private IpAddressUtil() {
        // Private constructor to prevent instantiation
    }

    /**
     * Get the client's IP address from the HttpServletRequest.
     *
     * @param request HttpServletRequest object
     * @return Client's IP address
     */
    public static String getClientIpAddress(HttpServletRequest request) {
        final String[] HEADER_CANDIDATES = {
            "X-Forwarded-For",
            "Proxy-Client-IP",
            "WL-Proxy-Client-IP",
            "HTTP_X_FORWARDED_FOR",
            "HTTP_X_FORWARDED",
            "HTTP_X_CLUSTER_CLIENT_IP",
            "HTTP_CLIENT_IP",
            "HTTP_FORWARDED_FOR",
            "HTTP_FORWARDED",
            "HTTP_VIA",
            "REMOTE_ADDR"
        };

        for (String header : HEADER_CANDIDATES) {
            String ip = request.getHeader(header);
            if (ip != null && !ip.isEmpty() && !"unknown".equalsIgnoreCase(ip)) {
                // In case of multiple IPs, take the first one
                return ip.split(",")[0].trim();
            }
        }

        // Fallback to remote address if no headers provide the IP
        return request.getRemoteAddr();
    }
}

-----------------------------------------------------
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import javax.servlet.http.HttpServletRequest;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

class IpAddressUtilTest {

    @Mock
    private HttpServletRequest mockRequest;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testGetClientIpAddress_WithXForwardedForHeader() {
        // Mock the X-Forwarded-For header
        when(mockRequest.getHeader("X-Forwarded-For")).thenReturn("192.168.1.1, 192.168.1.2");
        when(mockRequest.getHeader("Proxy-Client-IP")).thenReturn(null);
        when(mockRequest.getRemoteAddr()).thenReturn("127.0.0.1");

        String ipAddress = IpAddressUtil.getClientIpAddress(mockRequest);

        // Assert that the first IP in the X-Forwarded-For header is returned
        assertEquals("192.168.1.1", ipAddress);
    }

    @Test
    void testGetClientIpAddress_WithProxyClientIpHeader() {
        // Mock the Proxy-Client-IP header
        when(mockRequest.getHeader("X-Forwarded-For")).thenReturn(null);
        when(mockRequest.getHeader("Proxy-Client-IP")).thenReturn("10.0.0.1");
        when(mockRequest.getRemoteAddr()).thenReturn("127.0.0.1");

        String ipAddress = IpAddressUtil.getClientIpAddress(mockRequest);

        // Assert that the Proxy-Client-IP header value is returned
        assertEquals("10.0.0.1", ipAddress);
    }

    @Test
    void testGetClientIpAddress_WithNoHeaders() {
        // Mock no relevant headers
        when(mockRequest.getHeader("X-Forwarded-For")).thenReturn(null);
        when(mockRequest.getHeader("Proxy-Client-IP")).thenReturn(null);
        when(mockRequest.getRemoteAddr()).thenReturn("127.0.0.1");

        String ipAddress = IpAddressUtil.getClientIpAddress(mockRequest);

        // Assert that the remote address is returned
        assertEquals("127.0.0.1", ipAddress);
    }

    @Test
    void testGetClientIpAddress_WithUnknownHeader() {
        // Mock a header with "unknown"
        when(mockRequest.getHeader("X-Forwarded-For")).thenReturn("unknown");
        when(mockRequest.getHeader("Proxy-Client-IP")).thenReturn(null);
        when(mockRequest.getRemoteAddr()).thenReturn("127.0.0.1");

        String ipAddress = IpAddressUtil.getClientIpAddress(mockRequest);

        // Assert that the remote address is returned
        assertEquals("127.0.0.1", ipAddress);
    }

    @Test
    void testGetClientIpAddress_WithMultipleHeaders() {
        // Mock multiple headers
        when(mockRequest.getHeader("X-Forwarded-For")).thenReturn(null);
        when(mockRequest.getHeader("Proxy-Client-IP")).thenReturn(null);
        when(mockRequest.getHeader("WL-Proxy-Client-IP")).thenReturn("172.16.0.1");
        when(mockRequest.getRemoteAddr()).thenReturn("127.0.0.1");

        String ipAddress = IpAddressUtil.getClientIpAddress(mockRequest);

        // Assert that the WL-Proxy-Client-IP header value is returned
        assertEquals("172.16.0.1", ipAddress);
    }

    @Test
    void testGetClientIpAddress_WithCommaSeparatedIps() {
        // Mock X-Forwarded-For header with multiple IPs
        when(mockRequest.getHeader("X-Forwarded-For")).thenReturn("203.0.113.1, 203.0.113.2");
        when(mockRequest.getRemoteAddr()).thenReturn("127.0.0.1");

        String ipAddress = IpAddressUtil.getClientIpAddress(mockRequest);

        // Assert that the first IP is returned
        assertEquals("203.0.113.1", ipAddress);
    }
}
