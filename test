public class LogProcessorFactory {

    public static LogProcessor getLogProcessor(LogType logType) {
        switch (logType) {
            case EXCEPTION:
                return new ExceptionLogProcessor();
            case REQUEST:
                return new RequestLogProcessor(); // For request logging (optional)
            case RESPONSE:
                return new ResponseLogProcessor(); // For response logging (optional)
            default:
                throw new IllegalArgumentException("Unknown log type: " + logType);
        }
    }
}
-----------------------------------------------
public interface LogProcessor {
    void process(Object input); // Input can be customized based on your needs
}
----------------------------------
import javax.servlet.http.HttpServletResponse;

public class ResponseLogProcessor implements LogProcessor {

    @Override
    public void process(Object object) {
        if (object instanceof HttpServletResponse) {
            HttpServletResponse response = (HttpServletResponse) object;
            LoggingUtil.logResponse(response); // Delegate to LoggingUtil for response logging
        } else {
            throw new IllegalArgumentException("Invalid object type for ResponseLogProcessor");
        }
    }
}
-----------------------------
package com.example.logging.processors;

import com.example.logging.util.LoggingUtil;

public class ExceptionLogProcessor implements LogProcessor {

    @Override
    public void process(Object input) {
        if (input instanceof Exception) {
            LoggingUtil.logException((Exception) input);
        } else {
            throw new IllegalArgumentException("Invalid input for ExceptionLogProcessor");
        }
    }
}
--------------------------------------
import javax.servlet.http.HttpServletRequest;

public class RequestLogProcessor implements LogProcessor {

    @Override
    public void process(Object object) {
        if (object instanceof HttpServletRequest) {
            HttpServletRequest request = (HttpServletRequest) object;
            LoggingUtil.logRequest(request); // Delegate to LoggingUtil for request logging
        } else {
            throw new IllegalArgumentException("Invalid object type for RequestLogProcessor");
        }
    }
}

--------------------------------------
@Log4j2
public class LoggingUtil {

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    public static void log(LogRequest logRequest) {
        try {
            log.info("Request: {}", OBJECT_MAPPER.writeValueAsString(logRequest));
        } catch (JsonProcessingException e) {
            log.error("Error logging request: {}", e.getMessage(), e);
        }
    }

    public static void log(LogResponse logResponse) {
        try {
            log.info("Response: {}", OBJECT_MAPPER.writeValueAsString(logResponse));
        } catch (JsonProcessingException e) {
            log.error("Error logging response: {}", e.getMessage(), e);
        }
    }
}
---------------------------------------
public class RequestCachingLoggingFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        try {
            if (request instanceof HttpServletRequest) {
                LogProcessor requestProcessor = LogProcessorFactory.getLogProcessor(LogType.REQUEST);
                requestProcessor.process(request); // Log the request
            }

            chain.doFilter(request, response);

        } catch (Exception e) {
            LoggingUtil.logException(e); // Log the exception
            throw e; // Re-throw the exception to ensure proper error handling
        }
    }
}
-----------------------------------------------
public class ResponseCachingLoggingFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        ContentCachingResponseWrapper wrappedResponse = null;

        try {
            if (response instanceof HttpServletResponse) {
                wrappedResponse = new ContentCachingResponseWrapper((HttpServletResponse) response);
            }

            chain.doFilter(request, wrappedResponse != null ? wrappedResponse : response);

            if (wrappedResponse != null) {
                LogProcessor responseProcessor = LogProcessorFactory.getLogProcessor(LogType.RESPONSE);
                responseProcessor.process(wrappedResponse); // Log the response
                wrappedResponse.copyBodyToResponse();
            }

        } catch (Exception e) {
            LoggingUtil.logException(e); // Log the exception
            throw e; // Re-throw the exception to ensure proper error handling
        }
    }
}
----------------------------------------
public class RequestCachingLoggingFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        try {
            if (request instanceof HttpServletRequest) {
                chain.doFilter(request, response);
            }
        } catch (Exception e) {
            // Use factory to get the appropriate log processor
            LogProcessor exceptionProcessor = LogProcessorFactory.getLogProcessor(LogType.EXCEPTION);
            exceptionProcessor.process(e); // Process the exception
            throw e; // Re-throw the exception
        }
    }
}
------------------------------------------
package com.example.logging.util;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class LoggingUtil {

    private static final Logger logger = LogManager.getLogger(LoggingUtil.class);

    public static void logException(Exception exception) {
        if (exception != null) {
            logger.error("Exception occurred: {}", exception.getMessage(), exception);
        } else {
            logger.warn("Attempted to log a null exception.");
        }
    }
}
-----------------------------------------------------
package com.example.logging.util;

import com.example.logging.models.LoggingRequest;
import com.example.logging.models.MessageInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

public class HttpRequestLoggingHelper {

    private static final Logger log = LoggerFactory.getLogger(HttpRequestLoggingHelper.class);

    private HttpRequestLoggingHelper() {
        // Private constructor to prevent instantiation
    }

    public static Optional<LoggingRequest> buildRequestLog(HttpServletRequest request) {
        return Optional.ofNullable(request).map(req -> {
            try {
                String method = Optional.ofNullable(req.getMethod()).orElse("UNKNOWN");
                String uri = Optional.ofNullable(req.getRequestURI()).orElse("UNKNOWN");

                Map<String, String> headers = Optional.ofNullable(Collections.list(req.getHeaderNames()))
                        .map(list -> list.stream()
                                .collect(Collectors.toMap(
                                        headerName -> headerName,
                                        req::getHeader
                                )))
                        .orElse(Collections.emptyMap());

                String body = getRequestBody(req);
                String clientIpAddress = getClientIpAddress(req);
                MessageInfo messageInfo = getMessageInfo(clientIpAddress);

                return new LoggingRequest(method, uri, headers, body, messageInfo);
            } catch (Exception e) {
                log.error("Error building request log: {}", e.getMessage(), e);
                return null;
            }
        });
    }

    private static String getRequestBody(HttpServletRequest request) {
        try {
            if (request.getInputStream() != null) {
                byte[] content = request.getInputStream().readAllBytes();
                return new String(content, StandardCharsets.UTF_8);
            }
        } catch (IOException e) {
            log.warn("Failed to read request body: {}", e.getMessage());
        }
        return "Request body not available or unreadable.";
    }

    private static String getClientIpAddress(HttpServletRequest request) {
        String forwardedFor = request.getHeader("X-Forwarded-For");
        if (forwardedFor != null) {
            return forwardedFor.split(",")[0];
        }
        return request.getRemoteAddr();
    }

    private static MessageInfo getMessageInfo(String clientIpAddress) {
        return new MessageInfo(
                String.valueOf(System.currentTimeMillis()),
                "INFO",
                null,
                "ApplicationName", // Replace with actual application name
                "ENV", // Replace with actual environment
                clientIpAddress
        );
    }
}
----------------------------------------
package com.example.logging.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.log4j.Log4j2;
import org.springframework.web.util.ContentCachingResponseWrapper;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Log4j2
public class HttpResponseLogHelper {

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private HttpResponseLogHelper() {
        // Private constructor to prevent instantiation
    }

    public static void logResponse(final HttpServletResponse response) {
        Optional.ofNullable(response).ifPresentOrElse(
            res -> {
                if (res instanceof ContentCachingResponseWrapper) {
                    handleContentCachingResponse((ContentCachingResponseWrapper) res);
                } else {
                    log.warn("HttpServletResponse is not wrapped with ContentCachingResponseWrapper, cannot log response body.");
                }
            },
            () -> log.warn("HttpServletResponse is null, cannot log response.")
        );
    }

    private static void handleContentCachingResponse(final ContentCachingResponseWrapper responseWrapper) {
        try {
            final String responseBody = extractResponseBody(responseWrapper);
            final Map<String, String> headers = extractHeaders(responseWrapper);
            final int statusCode = responseWrapper.getStatus();

            logDetailedResponse(headers, statusCode, responseBody);
            responseWrapper.copyBodyToResponse();
        } catch (final Exception e) {
            handleLoggingException(e);
        }
    }

    private static String extractResponseBody(final ContentCachingResponseWrapper responseWrapper) {
        return new String(responseWrapper.getContentAsByteArray(), StandardCharsets.UTF_8);
    }

    private static Map<String, String> extractHeaders(final ContentCachingResponseWrapper responseWrapper) {
        return Optional.ofNullable(responseWrapper.getHeaderNames())
            .map(names -> names.stream()
                .collect(Collectors.toMap(
                    h -> h,
                    h -> Optional.ofNullable(responseWrapper.getHeader(h)).orElse("")
                )))
            .orElse(Collections.emptyMap());
    }

    private static void logDetailedResponse(
        final Map<String, String> headers,
        final int statusCode,
        final String responseBody
    ) throws JsonProcessingException {
        final String logLevel = "INFO"; // Replace with logic to determine log level
        final String applicationName = "YourApplicationName"; // Replace with your application name
        final String environment = "YourEnvironment"; // Replace with logic to fetch environment

        final LoggingResponse responseLog = new LoggingResponse(statusCode, headers, responseBody);
        log.info("Response: {}", OBJECT_MAPPER.writeValueAsString(responseLog));
    }

    private static void handleLoggingException(final Exception e) {
        if (e instanceof JsonProcessingException) {
            log.error("Error processing JSON for response log: {}", e.getMessage(), e);
        } else if (e instanceof IOException) {
            log.error("Error copying response body to client: {}", e.getMessage(), e);
        } else {
            log.error("Unexpected error logging response: {}", e.getMessage(), e);
        }
    }
}
