import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class LogProcessorServiceTest {

    @InjectMocks
    private LogProcessorService logProcessorService;

    @Mock
    private Logger mockLogger;

    @Captor
    private ArgumentCaptor<String> logCaptor;

    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    }

    @Test
    void testProcessLog_RequestLog() throws Exception {
        // Arrange
        TestLogObject testObject = new TestLogObject("Test", 123);
        String expectedJson = objectMapper.writeValueAsString(testObject);

        // Act
        logProcessorService.processLog(testObject, "REQUEST");

        // Assert
        verify(mockLogger).info(logCaptor.capture());
        String actualLog = logCaptor.getValue();
        assertTrue(actualLog.contains("Request Log:"));
        assertTrue(actualLog.contains(expectedJson));
    }

    @Test
    void testProcessLog_ResponseLog() throws Exception {
        TestLogObject testObject = new TestLogObject("ResponseTest", 456);
        String expectedJson = objectMapper.writeValueAsString(testObject);

        logProcessorService.processLog(testObject, "RESPONSE");

        verify(mockLogger).info(logCaptor.capture());
        String actualLog = logCaptor.getValue();
        assertTrue(actualLog.contains("Response Log:"));
        assertTrue(actualLog.contains(expectedJson));
    }

    @Test
    void testProcessLog_ErrorLog() throws Exception {
        TestLogObject testObject = new TestLogObject("ErrorTest", 500);
        String expectedJson = objectMapper.writeValueAsString(testObject);

        logProcessorService.processLog(testObject, "ERROR");

        verify(mockLogger).error(logCaptor.capture());
        String actualLog = logCaptor.getValue();
        assertTrue(actualLog.contains("Error Log:"));
        assertTrue(actualLog.contains(expectedJson));
    }

    @Test
    void testProcessLog_UnknownType() {
        logProcessorService.processLog("Unknown", "UNKNOWN");

        verify(mockLogger).info(logCaptor.capture());
        String actualLog = logCaptor.getValue();
        assertTrue(actualLog.contains("Unknown Log Type: UNKNOWN"));
    }

    @Test
    void testProcessLog_ExceptionHandling() throws Exception {
        ObjectMapper faultyMapper = mock(ObjectMapper.class);
        when(faultyMapper.writeValueAsString(any())).thenThrow(new RuntimeException("Serialization Error"));

        LogProcessorService faultyService = new LogProcessorService() {
            @Override
            public void processLog(Object object, String logType) {
                try {
                    String logMessage = faultyMapper.writeValueAsString(object);
                    log.info("Request Log: {}", logMessage);
                } catch (Exception e) {
                    log.error("Failed to process log: {}", e.getMessage(), e);
                }
            }
        };

        faultyService.processLog(new TestLogObject("Faulty", 999), "REQUEST");

        verify(mockLogger).error(logCaptor.capture());
        assertTrue(logCaptor.getValue().contains("Failed to process log: Serialization Error"));
    }

    // Dummy class for test data
    private static class TestLogObject {
        public String name;
        public int id;

        public TestLogObject(String name, int id) {
            this.name = name;
            this.id = id;
        }
    }
}
